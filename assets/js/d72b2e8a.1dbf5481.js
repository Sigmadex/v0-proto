"use strict";(self.webpackChunkdocusaur=self.webpackChunkdocusaur||[]).push([[5689],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=u(n),m=o,f=c["".concat(l,".").concat(m)]||c[m]||p[m]||r;return n?a.createElement(f,s(s({ref:t},d),{},{components:n})):a.createElement(f,s({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=c;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var u=2;u<r;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8049:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return d},default:function(){return c}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],i={},l=void 0,u={unversionedId:"API Specification/libraries/AppState",id:"API Specification/libraries/AppState",isDocsHomePage:!1,title:"AppState",description:"This page provides an indepth explanation of what state is tracked in the contract to provide its functionality.  We can divide this state into 5 different subsystems.",source:"@site/docs/API Specification/libraries/AppState.md",sourceDirName:"API Specification/libraries",slug:"/API Specification/libraries/AppState",permalink:"/v0-proto/docs/API Specification/libraries/AppState",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IERC173",permalink:"/v0-proto/docs/API Specification/interfaces/IERC173"},next:{title:"LibAppStorage",permalink:"/v0-proto/docs/API Specification/libraries/LibAppStorage"}},d=[{value:"Sdex Subsystem",id:"sdex-subsystem",children:[],level:3},{value:"Farm Subsystem",id:"farm-subsystem",children:[{value:"Pools",id:"pools",children:[],level:4},{value:"Users",id:"users",children:[],level:4}],level:3},{value:"Vault Subsystem",id:"vault-subsystem",children:[],level:3},{value:"Penalty Pool Subsystem",id:"penalty-pool-subsystem",children:[],level:3},{value:"NFT Reward Subsystem",id:"nft-reward-subsystem",children:[],level:3}],p={toc:d};function c(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This page provides an indepth explanation of what state is tracked in the contract to provide its functionality.  We can divide this state into 5 different subsystems."),(0,r.kt)("h3",{id:"sdex-subsystem"},"Sdex Subsystem"),(0,r.kt)("p",null,"The Sdex Subsystem is responsible for holding the state required to implement the ERC-20 compliant Sdex Token"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"\nmapping(address => uint256) sdexBalances; // user address maps to amount of Sdex owned\nmapping(address => mapping(address => uint256))  sdexAllowances; //user address allows other address the spending of amount\nuint256 sdexTotalSupply; //total Amount of Sdex in existance\n\nstring sdexName; //name of token\nstring sdexSymbol; // symbol of token\nuint8 sdexDecimals; // decimals for token\n\n")),(0,r.kt)("h3",{id:"farm-subsystem"},"Farm Subsystem"),(0,r.kt)("h4",{id:"pools"},"Pools"),(0,r.kt)("p",null,"State concerning the pools are contained within the {PoolInfo} struct. Which are mapped by a unique id in the ",(0,r.kt)("inlineCode",{parentName:"p"},"poolInfo")," mapping. the ",(0,r.kt)("inlineCode",{parentName:"p"},"poolLength")," retreives the amount of pools if one wishes to iterate over all of them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"struct PoolTokenData {\n  IERC20 token; // An ERC20 interface of a token in a pool, can be LP tokens, Sdex, stables or others\n  uint256 supply; // the total amount of this token within this specific pool\n  uint256 accSdexPerShare; // the amount of accumulated blockrewards since the pools birth per unit supply\n}\n\nstruct PoolInfo {\n  PoolTokenData[] tokenData; // Array of PoolTokenDatas, normally of length 1, or 2, but can be many\n  uint256 allocPoint; // allocation points, used to determine what proportion of block rewards this pool gets per block\n  uint256 lastRewardBlock; // SDEX lazy updates on user input, sometimes many block go by before update, used to catch up state\n}\n\nmapping(uint256 => PoolInfo) poolInfo; // mapping holding all pools\nuint256 poolLength // pool Iterator, max number of pools, used to add another and find an iterator over all pools\n")),(0,r.kt)("p",null,"The Farm subsystem also uses these globals across all farms"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"uint256 sdexPerBlock; // amount of Sdex emitted per block\nuint256 BONUS_MULTIPLIER; // sdexPerBlock can be amplified or dampened temporaily by toggling this\nuint256 totalAllocPoint; // total amount of farm allocation points, used in determining what proportion of sdex per block a farm receives\nuint256 startBlock; // block where awards start being minted\n")),(0,r.kt)("h4",{id:"users"},"Users"),(0,r.kt)("p",null,"Data on specific users' claims within pools is stored through the ",(0,r.kt)("inlineCode",{parentName:"p"},"userInfo")," mapping.  which takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"poolid")," and their ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," and outputs the {UserInfo} object. When a user deposits funds into a pool with ",(0,r.kt)("inlineCode",{parentName:"p"},"poolid")," a {UserPosition} object is created with a ",(0,r.kt)("inlineCode",{parentName:"p"},"positionid"),".  This {UserPosition} objects holds the specific deposit data, while the {UserTokenData} object keeps tracks of relevant sum totals of that user in that pool."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"struct UserPosition {\n  uint256 startBlock; // block this position was created at\n  uint256 endBlock; // block the user states is the finish of his staking period\n  uint256[] amounts; // array of amounts deposited, same length and order as the pools `tokenData`\n  uint256[] rewardDebts; // tracks users rewards at t-1 to know how much to give next\n  address nftReward; // the address of the specific NFT reward if applied (address(0)) is no NFT\n  uint256 nftid; // the id of the nft at the above address (0 for no NFT)\n}\n\nstruct UserTokenData {\n  uint256 amount; // sum of all tokens of this type across all open positions\n  uint256 totalRewardDebt; // sum of all users rewards at t-1 to know what to give next\n}\n\nstruct UserInfo {\n  UserTokenData[] tokenData; // array of {TokenData} same order as pools tokenData\n  UserPosition[] positions; // an array of all users created positions in this pool\n  uint256 lastRewardBlock; // tracks how many blocks to update upon a lazy update initiated by user\n}\n\nmapping (uint256 => mapping (address => UserInfo)) userInfo; \n")),(0,r.kt)("h3",{id:"vault-subsystem"},"Vault Subsystem"),(0,r.kt)("p",null,"The Vault subsystem is a special 'trading bot' like system that operates on ",(0,r.kt)("inlineCode",{parentName:"p"},"poolid=0"),", the SDEX only farm. It exposes deposit withdraw functionality for the end users, and continually reinvests any block rewards on behalf of the users. Like farms, when a user deposits in the vault, a {VaultUserPosition} is created inside their {VaultUserInfo}"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"struct VaultUserPosition {\n  uint256 startBlock; // block where the deposit of SDEX occured\n  uint256 endBlock; // When the timestake is over\n  uint256 amount; // amount staked\n  uint256 shares; // proportion of ownership of assets in vault, used in calcs as Sdex is compounding\n  address nftReward; // address of applied NFT reward, (address(0) for no NFT)\n  uint256 nftid; // id of nft at address above, (0 for no NFT)\n}\n\nstruct VaultUserInfo {\n  uint256 shares; // number of total shares for a user\n  uint256 lastDepositedTime; // keeps track of deposited time for potential penalty\n  uint256 sdexAtLastUserAction; // keeps track of cake deposited at the last user action\n  uint256 lastUserActionTime; // keeps track of the last user action time\n  VaultUserPosition[] positions; // array of positions a user created by depositing\n}\n\nmapping(address => VaultUserInfo) vUserInfo; // user address maps to the {VaultUserInfo} object\n")),(0,r.kt)("p",null,"The Vault also contains the following global state for the ",(0,r.kt)("inlineCode",{parentName:"p"},"harvest")," functionality.  When compensates users a small amount in exchange for paying for the bot to autocompound everyones shares"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"uint256 vSdex; //internal count of how much Sdex the bot 'owns' in the diamond\n\nuint256 vTotalShares; // total amount of shares on vault\nuint256 vLastHarvestedTime; // last block where the harvest function was executed\nuint256 vTreasury; // an internal account of how much Sdex is collected by the perforance fee\n\nuint256 vMAX_PERFORMANCE_FEE; // 5%, max performance fee that can be set\nuint256 vMAX_CALL_FEE; // 1% , max call fee that can be set\n\nuint256 vPerformanceFee; // 2% , 2% of pending rewards in the vault are sent to treasury on harvest execution\nuint256 vCallFee; // 0.25%, 0.25% of pending rewards in the vault are sent to harvester\n")),(0,r.kt)("h3",{id:"penalty-pool-subsystem"},"Penalty Pool Subsystem"),(0,r.kt)("p",null,"The penalty/reward subsystem is responsible, calculating, accounting and distributing penalties and rewards on the platform.  Each token that is listed on the platform has one penalty and reward pool, upon the exception of the SDEX token itself, which additionally has an accumulatedSdex penalty and reward pool respectively.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"\nuint256 accSdexPenaltyPool; // amount of Sdex in the AccSdex Penalty Pool\nuint256 accSdexRewardPool; // amount of claims outstanding in NFT rewards\nuint256 accSdexPaidOut; // amount that has been paid out in NFT rewards\n\n\nstruct TokenRewardData {\n  uint256 blockAmountGlobal; // sum of all blocksStaked*amountStaked for all positions in this token, used to calc amount received from penalty pool\n  uint256 rewarded; // amount of claims currently outstanding of this token in NFT rewards\n  uint256 penalties; // amount of tokens currently in penalty pool\n  uint256 paidOut; // amount of NFT rewards that have been paid out over all time\n}\nmapping (address => TokenRewardData) tokenRewardData;\n")),(0,r.kt)("h3",{id:"nft-reward-subsystem"},"NFT Reward Subsystem"),(0,r.kt)("p",null,"The reward subsystem concerns acting as a middleware between the NFT rewards, the NFT Reward Facets,  and the Penalty Subsystem"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"struct Reward{\n  bytes4 withdrawSelector; // function signature for an NFT rewards withdraw function\n  bytes4 vaultWithdrawSelector; // function signature for an NFT rewards vault withdraw selector\n  bytes4 rewardSelector; // function signature for an NFT rewards' create reward selector\n}\nmapping (address => Reward) rewards; // nft address to {Reward} router struct\n\nmapping (address => address[]) validRewards; // token address maps to nft addresses that can be minted for it\nenum REWARDPOOL{BASE, ACC} // determines which reward pool the nft pulls its underlying value from\nuint256 seed; // number that assists in the pseudo random picking of which nft to mint for reward\n")))}c.isMDXComponent=!0}}]);